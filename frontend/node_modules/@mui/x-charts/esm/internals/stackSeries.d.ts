import { stackOrderAppearance as d3StackOrderAppearance, stackOrderAscending as d3StackOrderAscending, stackOrderDescending as d3StackOrderDescending, stackOrderInsideOut as d3StackOrderInsideOut, stackOrderNone as d3StackOrderNone, stackOrderReverse as d3StackOrderReverse, stackOffsetExpand as d3StackOffsetExpand, stackOffsetDiverging as d3StackOffsetDiverging, stackOffsetNone as d3StackOffsetNone, stackOffsetSilhouette as d3StackOffsetSilhouette, stackOffsetWiggle as d3StackOffsetWiggle, type Series } from '@mui/x-charts-vendor/d3-shape';
import type { StackOffsetType, StackOrderType } from "../models/stacking.js";
import { type SeriesId, type StackableSeriesType } from "../models/seriesType/common.js";
type FormatterParams<T> = {
  series: Record<SeriesId, T>;
  seriesOrder: SeriesId[];
  defaultStrategy?: {
    stackOrder?: StackOrderType;
    stackOffset?: StackOffsetType;
  };
};
export type StackingGroupsType = {
  ids: SeriesId[];
  stackingOrder: (series: Series<any, any>) => number[];
  stackingOffset: (series: Series<any, any>, order: Iterable<number>) => void;
}[];
export declare const StackOrder: {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: typeof d3StackOrderAppearance;
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: typeof d3StackOrderAscending;
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: typeof d3StackOrderDescending;
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: typeof d3StackOrderInsideOut;
  /**
   * Given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: typeof d3StackOrderNone;
  /**
   * Reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: typeof d3StackOrderReverse;
};
export declare const StackOffset: {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: typeof d3StackOffsetExpand;
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: typeof d3StackOffsetDiverging;
  /**
   * Applies a zero baseline.
   * */
  none: typeof d3StackOffsetNone;
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: typeof d3StackOffsetSilhouette;
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: typeof d3StackOffsetWiggle;
};
/**
 * Takes a set of series and groups their ids
 * @param series the object of all bars series
 * @returns an array of groups, including the ids, the stacking order, and the stacking offset.
 */
export declare const getStackingGroups: <T extends StackableSeriesType>(params: FormatterParams<T>) => StackingGroupsType;
export {};